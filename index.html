<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Gesture Typed Particle Text</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Three.js -->
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>

<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.min.js"></script>

<style>
html,body{margin:0;background:#0b0b0f;overflow:hidden;font-family:sans-serif}
#video{display:none}
#ui{
  position:fixed;bottom:20px;left:50%;transform:translateX(-50%);
  color:#fff;font-size:18px;opacity:.9
}
</style>
</head>
<body>

<video id="video" autoplay></video>
<div id="ui">Typed Text: <b id="text">A</b></div>

<script>
/* ================= THREE ================= */
const scene=new THREE.Scene()
const camera=new THREE.PerspectiveCamera(60,innerWidth/innerHeight,1,1000)
camera.position.z=120

const renderer=new THREE.WebGLRenderer({antialias:true})
renderer.setSize(innerWidth,innerHeight)
document.body.appendChild(renderer.domElement)

const COUNT=10000
const geo=new THREE.BufferGeometry()
const pos=new Float32Array(COUNT*3)
for(let i=0;i<pos.length;i+=3){
  pos[i]=(Math.random()-.5)*300
  pos[i+1]=(Math.random()-.5)*200
  pos[i+2]=(Math.random()-.5)*200
}
geo.setAttribute("position",new THREE.BufferAttribute(pos,3))

const mat=new THREE.PointsMaterial({size:1,color:0x7f7cff})
const particles=new THREE.Points(geo,mat)
scene.add(particles)

/* ================= TEXT TO POINTS ================= */
function textPoints(text){
  const c=document.createElement("canvas")
  const ctx=c.getContext("2d")
  c.width=800;c.height=300
  ctx.font="bold 150px Arial"
  ctx.fillStyle="#fff"
  ctx.textAlign="center"
  ctx.textBaseline="middle"
  ctx.fillText(text,c.width/2,c.height/2)
  const data=ctx.getImageData(0,0,c.width,c.height).data
  const pts=[]
  for(let y=0;y<c.height;y+=4){
    for(let x=0;x<c.width;x+=4){
      if(data[(y*c.width+x)*4]>200){
        pts.push({x:x-c.width/2,y:c.height/2-y,z:0})
      }
    }
  }
  return pts
}

function morph(text){
  const target=textPoints(text)
  const arr=geo.attributes.position.array
  for(let i=0;i<arr.length;i+=3){
    const t=target[i/3]||target[Math.random()*target.length|0]
    gsap.to(arr,{
      [i]:t.x*.15,[i+1]:t.y*.15,[i+2]:0,
      duration:1.5,ease:"power3.out",
      onUpdate:()=>geo.attributes.position.needsUpdate=true
    })
  }
}

/* ================= GESTURE LOGIC ================= */
let letters="ABCDEFGHIJKLMNOPQRSTUVWXYZ"
let letterIndex=0
let typed="A"
let lastGesture=""

document.getElementById("text").innerText=typed

function detectGesture(lm){
  const thumb=lm[4],index=lm[8],middle=lm[12]
  const palmOpen=index.y<middle.y && middle.y<lm[16].y
  const fist=index.y>lm[6].y
  if(palmOpen) return "PALM"
  if(fist) return "FIST"
  if(Math.abs(index.y-middle.y)<0.03) return "TWO"
  return "INDEX"
}

function handleGesture(g){
  if(g===lastGesture) return
  lastGesture=g

  if(g==="INDEX"){
    letterIndex=(letterIndex+1)%letters.length
    typed=typed.slice(0,-1)+letters[letterIndex]
  }
  if(g==="PALM"){
    typed+=letters[letterIndex]
  }
  if(g==="FIST"){
    typed=typed.slice(0,-1)||"A"
  }
  if(g==="TWO"){
    typed+=" "
  }

  document.getElementById("text").innerText=typed
  morph(typed)
}

/* ================= MEDIAPIPE ================= */
const hands=new Hands({
  locateFile:file=>`https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
})
hands.setOptions({maxNumHands:1,minDetectionConfidence:.7})
hands.onResults(res=>{
  if(res.multiHandLandmarks?.length){
    handleGesture(detectGesture(res.multiHandLandmarks[0]))
  }
})

const cam=new Camera(document.getElementById("video"),{
  onFrame:async()=>hands.send({image:video}),
  width:640,height:480
})
cam.start()

/* ================= LOOP ================= */
function animate(){
  requestAnimationFrame(animate)
  particles.rotation.y+=.0006
  renderer.render(scene,camera)
}
animate()

window.onresize=()=>{
  camera.aspect=innerWidth/innerHeight
  camera.updateProjectionMatrix()
  renderer.setSize(innerWidth,innerHeight)
}
</script>
</body>
</html>
