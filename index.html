<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Morphing Particles To Text</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Three.js + GSAP -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      background: #0b0b0f;
      overflow: hidden;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    }

    canvas {
      position: fixed;
      inset: 0;
    }

    .title {
      position: absolute;
      top: 20px;
      width: 100%;
      text-align: center;
      color: #fff;
      font-size: 28px;
      letter-spacing: 1px;
      opacity: 0.85;
      z-index: 10;
    }

    .footer {
      position: absolute;
      bottom: 18px;
      width: 100%;
      text-align: center;
      color: #aaa;
      font-size: 14px;
      opacity: 0.6;
    }
  </style>
</head>
<body>

<div class="title">Morphing Particles To Text</div>
<div class="footer">Three.js • GSAP • Single File</div>

<script>
/* =======================
   BASIC SCENE SETUP
======================= */
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.z = 120;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
document.body.appendChild(renderer.domElement);

/* =======================
   PARTICLES
======================= */
const PARTICLE_COUNT = 12000;
const geometry = new THREE.BufferGeometry();
const positions = new Float32Array(PARTICLE_COUNT * 3);

for (let i = 0; i < positions.length; i += 3) {
  positions[i] = (Math.random() - 0.5) * 400;
  positions[i + 1] = (Math.random() - 0.5) * 200;
  positions[i + 2] = (Math.random() - 0.5) * 200;
}

geometry.setAttribute(
  'position',
  new THREE.BufferAttribute(positions, 3)
);

const material = new THREE.PointsMaterial({
  size: 1.2,
  color: 0x7f7cff,
  transparent: true,
  opacity: 0.9,
});

const particles = new THREE.Points(geometry, material);
scene.add(particles);

/* =======================
   TEXT → POINTS
======================= */
function createTextPoints(text) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');

  canvas.width = 800;
  canvas.height = 300;

  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.font = 'bold 160px Arial';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillStyle = '#fff';
  ctx.fillText(text, canvas.width / 2, canvas.height / 2);

  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
  const points = [];

  for (let y = 0; y < canvas.height; y += 3) {
    for (let x = 0; x < canvas.width; x += 3) {
      const index = (y * canvas.width + x) * 4;
      if (imageData[index] > 200) {
        points.push({
          x: x - canvas.width / 2,
          y: canvas.height / 2 - y,
          z: 0
        });
      }
    }
  }
  return points;
}

/* =======================
   MORPH FUNCTION
======================= */
function morphToText(text) {
  const target = createTextPoints(text);
  const pos = particles.geometry.attributes.position.array;

  for (let i = 0; i < pos.length; i += 3) {
    const t = target[i / 3] || target[Math.floor(Math.random() * target.length)];

    gsap.to(pos, {
      [i]: t.x * 0.15,
      [i + 1]: t.y * 0.15,
      [i + 2]: t.z,
      duration: 2,
      ease: "power3.inOut",
      onUpdate: () => {
        particles.geometry.attributes.position.needsUpdate = true;
      }
    });
  }
}

/* =======================
   TEXT LOOP
======================= */
const words = ["Follow", "Create", "Inspire", "Magic"];
let index = 0;

function nextWord() {
  morphToText(words[index]);
  index = (index + 1) % words.length;
}

nextWord();
setInterval(nextWord, 4000);

/* =======================
   ANIMATE
======================= */
function animate() {
  requestAnimationFrame(animate);
  particles.rotation.y += 0.0006;
  renderer.render(scene, camera);
}
animate();

/* =======================
   RESIZE
======================= */
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
